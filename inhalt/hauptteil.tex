\chapter{Numerische Integrationsverfahren für Anfangswertprobleme}
\label{kap:hauptteil}
NOCH SCHAUEN, DASS f(x,t) oder f(t,x) konsistent dargestellt ist!
EVENTUELL: $f_{n}= f(x_n,t_n)$ als Schreibweise einfuehren!! Kann einiges erleichtern!

Ausgangslage: Numerische Lösung von Anfangswertproblemen. Systeme beschrieben durch allgemeine Zustandsdarstellung:
(Zur Einfachheit Eingrößensysteme.)
\begin{align}
\dot{\vec{x}}\tt&= \vec{A}\, \vec{x}\tt + \vec{b} \, u\tt,\qquad \vec{x}(0)=\vec{x}_0 \label{eq:DGL}\\
y\tt&= \vec{c}^T\, \vec{x}\tt
\end{align}
Es ergibt sich als Lösung von $\vec{x}\tt$:
\begin{align}
x\tt = x_0 + \int\limits_0^t \dot{x}(x,t) \d t 
\end{align}
Dafür numerische Lösung erforderlich. Dabei wird mit der (zunächst festen) Schrittweite $T$ gerechnet.
Schreibweise festlegen: $x_i$ bezeichnet numerischen Wert im $i$-ten Abtastzeitpunkt, $t_i$, die zugehoerigen Zeiten.
Allgemein soll also in jedem Schritt eine Lösung
\begin{align}
	x_{i+1} = \Phi(x, t)
\end{align}
mit noch unbekannter Verfahrensfunktion $\Phi(x,t)$ bestimmt werden.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Einschrittverfahren}
\subsection{Explizites Eulerverfahren}
Einfachstes Verfahren, ergibt sich aus dem Taylor-Satz erster Ordnung. Steigung wird in jedem Zeitschritt berechnet und als konstant angenommen. (Zur Verdeutlichung im Zuge dieser Arbeit nur eine Zustandsgröße!)
\begin{align}
		&\frac{\d x}{\d t}=\lambda \dd x + b\dd u \\
		\Rightarrow & \frac{\Delta x}{T} = \lambda \dd x + b \dd u \\
		\Rightarrow & x_{i+1} = x_i+\Delta x_i = x_i + (\lambda \dd x_i + b\dd u_i) \dd T\\
		\Rightarrow & \text{Stabilitätsanalyse mit digitaler Regelung Methoden machen!!}
\end{align}


\subsection{Impliztes Eulerverfahren}
Andere Möglichkeit: Annahme der Steigung des $i+1$-ten Schrittes für $\Delta x$.
\begin{align}
	x_{i+1}&= x_i + \Delta x_{i+1}\\
	x_{i+1}&=x_i + \Delta x_{i+1} \ \text{mit}\\
	\Delta x_{i+1} &= (\lambda \dd x_{i+1} + b \dd u_{i+1}) \dd T \ \text{(vorherige Gl. einsetzen)}\\
	\Rightarrow \Delta x_{i+1}&= (1-\lambda \dd T)^{-1} \dd (b\dd u_{i+1} + \lambda x_i)\dd T
\end{align}
Es ergibt sich eine implizite Gleichung für die Steigung, und $u_{i+1}$ erforderlich.
Besonders: Führt immer zu Stabilität (unabhängig von der Schrittweite), wenn System stabil! (Eigenwerte anschauen!) ABER: oft auch für instabile Systeme stabil!

\subsection{Trapezregel/Heun-Verfahren}Referenz auf SIEMENS SKRIPT
Kombination der beiden Euler-Verfahren $\Rightarrow$ höhere Genauigkeit!\\
Mittelwert der Steigungen im $i$-ten und $i+1$-ten Schritt:
\begin{align}
	x_{i+1} &= x_i + \Delta x_i = \\
			& = x_i + T \dd \eh \dd \Big(f\big(x_i,t\big) + f\big(x_{i+1},t+T\big)  \Big).
\end{align}
Dadurch ergibt sich allgemein ebenfalls ein implizites Verfahren. Dies kann nun also möglicherweise nichtlineares Gleichungssystem gelöst werden, oder durch Abschätzung des unbekannten Wertes $f\big(x_{i+1},t+T\big)$ durch das explizite Euler-Verfahren erhält man das Heun-Verfahren nach \cite{gruene}:
\begin{align*}
	x_{i+1} &= x_i + \Delta x_i = \\
			& = x_i + T \dd \eh \dd \Big(f\big(x_i,t\big) + f\big( x_i +  T \dd f(x_i,t)  ,t+T\big) \Big).
\end{align*}
%Weitere Möglichkeiten, siehe Extrapolationsverfahren.

\subsection{Runge-Kutta-Verfahren}
Um die bisher betrachteten Methoden zu verbessern, gibt es mehrere Ansätze. Ein naheliegender Gedanke ist, statt nur der Rechten Seite der gew. DGL (REF!), Zeitableitungen höherer Ordnung in die Abschätzung einzubauen. Dies führt zu den Taylor-Methoden, welche auf der Taylor-Satz basieren.
Da die Differentation der Rechten Seite jedoch nach \cite{gruene} mit verhältnismäßig großem rechnerischen Aufwand verbunden ist, sind diese Verfahren in der Praxis eher ungebräuchlich und sollen im Rahmen dieser Arbeit nicht näher betrachtet werden.

Wie in \cite{gruene} gezeigt wird, lässt sich der \textit{globale} Fehler $e(t_i):= \norm{x_i - x(t_i)}$ gängiger Integrationsverfahren durch
\begin{align}
	e(t) = \mathcal{O}(T^p)
\end{align}
abschätzen. (Getroffene Annahmen über die rechte Seite der DGL (\ref{eq:DGL}) sollen im Rahmen dieser Arbeit außer Acht gelassen werden und können in \cite{gruene} nachgelesen werden.) Dabei legt die Konsistenzordnung $p$ fest, wie schnell der globale Fehler gegen Null geht, wenn die Schrittweite verkleinert wird. Es kann gezeigt werden, dass die Konsistenzordnung der Euler-Verfahren $p=1$ beträgt. Das Heun-Verfahren ist mit $p=2$ bereits deutlich genauer.\\
Deshalb ist der erste Ansatz in der Praxis, die Idee der Trapezregel beziehungsweise des Heun-Verfahrens weiter zu führen und die Konvergenzordnung der Verfahren durch weitere Stützstellen zu erhöhen.
Dies führt zum allgemeinen Ansatz der $s$-\textit{stufigen} expliziten Runge-Kutta-Verfahren:
\begin{align}
	\Phi(x,t,T)&= x + T\, \sum\limits_{i=1}^s b_i\,k_i, \quad \text{mit} \\
	k_i &= f\left( t+c_i T,  x_k + T \,\sum\limits_{j=1}^{i-1} a_{ij} k_j    \right) \quad \text{für } i=1,\ldots,s.
\end{align}
Dabei wird die Rechte Seite der DGL an den Stützstellen $t+c_i\,T$ berechnet, wobei die vorhergehenden Stützstellen gewichtet mit den Koeffizienten $a_{ij}$ zur Berechnung des zur Stützstelle gehörenden Funktionswertes herangezogen werden. Die Gewichtung der berechneten Steigungen bei der Ermittlung des resultierendes Funktionswertes von $x_{k+1}$ erfolgt durch die Koeffizienten $b_i$. Mit dieser Darstellung ergeben die Runge-Kutta-Verfahren eine unendliche Menge verschiedener Verfahren zur Lösung des Problems.\\
Um die Runge-Kutta-Verfahren zu klassifizieren, werden die Koeffizienten $a_{ij},b_{i},c_{i}$ häufig in Form des Butcher-Schemas, nach Tabelle \ref{tab:ButEx} dargestellt.
\begin{table}
\centering
$
	\begin{array}{c|ccccc}
		c_1\\
		c_2 & a_{21}\\
		c_3 & a_{31} & a_{32}\\
		\vdots & \vdots & \vdots & \ddots \\
		c_s & a_{s1} & a_{s2}&\cdots & a_{s \, s-1}\\ \hline
		& b_1 & b_2 & \cdots & b_{s-1} & b_s
	\end{array}
$\\[\baselineskip]
\caption{Allgemeines Butcher-Schema expliziter Runge-Kutta-Verfahren}
\label{tab:ButEx}
\end{table}
Sowohl das explizite Euler-Verfahren (s=p=1), als auch das Heun-Verfahren (s=p=2) lassen sich auf diese Weise beschreiben. Darüber hinaus ist das \textit{klassische} Runge-Kutta-Verfahren (s=p=4) von großer Bedeutung. Für diese Verfahren ergeben sich die in Tabelle \ref{tab:Butcherexamples} dargestellten Butcher-Schemata:
\begin{table}
\centering
$
	\begin{array}[b]{c|c}
		0 &\\ \hline
		&1
	\end{array} \quad
	\begin{array}[b]{c|cc}
		0 &\\ 
		1&1 \\ \hline
		& \eh & \eh
	\end{array} \quad 
	\begin{array}[b]{c|cccc}
		0 &\\ 
		\eh&\eh \\ 
		\eh & 0 & \eh \\
		1&0&0&1 \\ \hline
		& \frac{1}{6}&\frac{2}{6}&\frac{2}{6}&\frac{1}{6}
	\end{array}
$\\[\baselineskip]
\caption{Butcher-Schemata für (von links nach rechts): Euler-Verfahren, Heun-Verfahren, \textit{klassisches} Runge-Kutta-Verfahren}
\label{tab:Butcherexamples}
\end{table}
Die selbe Vorgehensweise lässt sich für implizite Verfahren anwenden, sodass sich als Berechnungsvorschrift für $s$-\textit{stufige} implizite Runge-Kutta-Verfahren ergibt:
\begin{align}
	\Phi(x,t,T) &= x + T\, \sum\limits_{i=1}^s b_i \, k_i \quad \text{mit}\\
	k_i &= f\left(  t+c_i T , x_k + T\, \sum\limits_{j=1}^{s} a_{ij}k_j  \right) \quad \text{für } i=1,\ldots,s. 
\end{align}
Beispiele für implizite Runge-Kutta-Verfahren sind das bereits kennengelernte implizite Euler-Verfahren (s=p=1), die implizite Mittelpunktsregel (s=p=2), sowie die implizite Trapezregel (s=p=2), deren Butcher-Schemata in Tabelle \ref{tab:ButcherIm} dargestellt sind.
\begin{table}
	\centering
$
	\begin{array}[b]{c|c}
		1 & 1\\ \hline
		 &1
	\end{array} \quad
	\begin{array}[b]{c|c}
		\eh&\eh \\ \hline
		& 1
	\end{array} \quad 
	\begin{array}[b]{c|cc}
		0 & 0 & 0\\ 
		1&\eh & \eh \\  \hline
		& \eh & \eh
	\end{array}
$\\[\baselineskip]
\caption{Butcher-Schemata für implizite Verfahren (von links nach rechts): Euler, Mittelpunktsregel, Trapezregel}
\label{tab:ButcherIm}
\end{table}
Der Vorteil der impliziten Verfahren gegenüber den expliziten Verfahren wird sich bei Betrachtung des Stabilitätsverhaltens zeigen. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Schrittweitensteuerung (Adaption)}
Um die Verfahren weiter zu verbessern, liegt der Gedanke nahe, die bisher als konstant angenommene Schrittweite $T$ als steuerbar anzusehen, sodass $T_i$ an Stellen, bei welchen sich der Funktionswert stärker ändert, kleiner gewählt werden kann und an Stellen langsamer Änderungen hingegen größer. Aus Gründen der numerischen Effizienz ist es üblich, dass im $i$-ten Zeitschritt eine \glqq gute\grqq \ Schrittweite für den Übergang von $t_i$ nach $t_{i+1}$ bestimmt wird, jedoch keine Anpassung von vorhergehenden Schrittweiten mehr erfolgt.

Um die Schrittweite anzupassen wird gefordert, dass der \textit{lokale} Fehler $\varepsilon(t)$ unter einer gewissen Toleranzgrenze $tol$ liegen soll. Der \textit{lokale} Fehler ist dabei der Anteil am \textit{globalen} Fehler, der durch den Zeitschritt von $t_i$ bis $t_{i+1}$ hervorgerufen wird. Da die exakte Lösung des Funktionsverlaufs nicht bekannt ist, wird für das verwendete Verfahren $\Phi$ mit Konsistenzordnung $p$ ein anderes Verfahren $\hat{\Phi}$ zur Abschätzung des Fehlers herangezogen. Die Konsistenzordnung des zweiten Verfahrens $\hat{p}$ wird kleiner als die des verwendeten Verfahrens gewählt, sodass $p \geq \hat{p}+1$ gilt. Der Schritt von $t_i$ nach $t_{i+1} = t_i+T_i$ wird mit beiden Verfahren berechnet und die Norm der Differenz der Ergebnisse als \textit{Fehlerschätzer} $\overline{\varepsilon}$ bezeichnet.
\begin{equation}
	\overline{\varepsilon} := \norm{\hat{\Phi}(t_i,x_i,T_i) - \Phi(t_i,x_i,T_i)}.
\end{equation}
Mit Hilfe der Konvergenzeigenschaften lässt sich zeigen, dass die gewünschte Fehlertoleranz näherungsweise eingehalten wird, falls die Schrittweite durch 
\begin{equation}
	T_{\mathrm{neu}} = \sqrt[\hat{p}+1]{\frac{tol}{\overline{\varepsilon}}}T_{\mathrm{alt}}
	\label{eq:Schrittweite}
\end{equation}
angepasst wird. Da dies nur approximativ gilt, wird das Argument der Wurzel in der Praxis jedoch häufig durch einen \glqq Sicherheitsfaktor\grqq \ $f_{ac} \in ]0,1[$ (typisch: $0.9$) skaliert.

Nach der Berechnung des Fehlerschätzers $\overline{\varepsilon}$ im Zeitschritt $i$ wird dieser mit der zulässigen Toleranz verglichen. Ist der berechnete Fehler größer, als die zulässige Toleranz ($\overline{\varepsilon} > tol$), wird der selbe Zeitschritt mit der angepassten Schrittweite $T_{\mathrm{neu}}$ erneut berechnet.\\
Gilt jedoch $\overline{\varepsilon} \leq tol$, so ist die gewünschte Genauigkeit erreicht und die der Berechnung zu Grunde liegende Schrittweite wird für diesen Zeitschritt angenommen. Nun wird erneut (\ref{eq:Schrittweite}) berechnet und $T_\mathrm{neu}$ als Schrittweite $T_{i+1}$ für den nächsten Zeitschritt angenommen. Dies sorgt dafür, dass die Schrittweite bei hoher Genauigkeit auch vergrößert werden kann.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Eingebettete Runge-Kutta-Verfahren}
Um den Rechenaufwand der Beschriebenen Schrittweitenanpassung zu reduzieren, können die Verfahrensfunktionen $\Phi$ und $\hat{\Phi}$ so geschickt gewählt werden, dass bei deren Auswertungen auf gleiche Zwischenergebnisse zurückgegriffen werden kann. Dies führt auf die sehr häufig verwendeten eingebetteten Runge-Kutta verfahren. Die eingebetteten Verfahren werden mit $\mathrm{RK}p(\hat{p})$ bezeichnet.
Der Gedanke dahinter ist, dass sich die berechneten Werte der Stützstellen $k_i$ und $\hat{k}_i$ nicht unterscheiden, sondern lediglich deren Linearkombination. Das heißt die Koeffizienten $a_{ij}=\hat{a}_{ij}$ und $c_{i}=\hat{c}_{i}$ stimmen in beiden Verfahren überein. Es gilt lediglich $b_{i}\neq \hat{b}_{j}$. 
Für eingebettete Runge-Kutta-Verfahren lassen sich dehalb auch sehr einfach Butcher-Schemata nach Tabelle \ref{tab:ButcherEin} erstellen.
\begin{table}
	\centering
$
	\begin{array}{c|ccccc}
		c_1\\
		c_2 & a_{21}\\
		c_3 & a_{31} & a_{32}\\
		\vdots & \vdots & \vdots & \ddots \\
		c_s & a_{s1} & a_{s2}&\cdots & a_{s \, s-1}\\ \hline
		& b_1 & b_2 & \cdots & b_{s-1} & b_s \\ \hline
		& \hat{b}_1 & \hat{b}_2 & \cdots & \hat{b}_{s-1} & \hat{b}_{s}
	\end{array}
$\\[\baselineskip]
\caption{allgemeines Butcher-Schema für eingebettete Runge-Kutta-Verfahren}
\label{tab:ButcherEin}
\end{table}
Wie in \cite{gruene} gezeigt wird, muss in diesem Fall zur Konstruktion eines Verfahrens der Konsistenzordnung $\hat{p}=p-1$ ein Verfahren der Ordnung $\hat{s}=s+1$ gewählt werden. Für das klassische Runge-Kutta-Verfahren (s=p=4) ergibt sich dadurch das Butcher-Schema nach Tabelle \ref{tab:koeffbest}.
\begin{table}
		\centering
$
	\begin{array}{c|ccccc}
		0\\
		\eh & \eh \\[2pt]
		\eh & 0 & \eh \\[2pt]
		1 & 0 & 0 & 1 \\[2pt]%
		c_5 & a_{51} & a_{52}& a_{53} & a_{54}\\\hline
		& \tikzmark[2pt]{1}{$\frac{1}{6}$} & \frac{2}{6} & \frac{2}{6} & \frac{1}{6} & 0 \\[2pt] \hline
		& \tikzmark[2pt]{2}{$\hat{b}_1$} & \hat{b}_2 & \hat{b}_3 & \hat{b}_4 & \hat{b}_5
	\end{array}
$\\[\baselineskip]
\caption{Butcher-Schema zur Bestimmung der unbekannten Koeffizienten}
\label{tab:koeffbest}
\end{table}
Um das zugehörige Verfahren $\hat{\Phi}$ mit $\hat{s}=5$ und $\hat{p}=3$ zu bestimmen, müssen also die unbekannten Koeffizienten in \ref{tab:koeffbest} bestimmt werden. Dies kann in \cite{gruene} nachgelesen werden und soll an dieser Stelle nicht weiter vertieft werden.
Eines der am weitesten verbreiteten Verfahren ist das Dormand-Prince-RK5(4)-Verfahren, welches in der Numerik-Software \Matlab \ unter dem Namen \verb ode45  standardmäßig eingestellt ist. Die zugehörigen Koeffizienten können in \cite{gruene} nachgelesen werden.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Mehrschrittverfahren}
Die bisher betrachteten Verfahren sind dadurch charakterisiert, dass die Verfahrensfunktion $\Phi(x,t)$ lediglich vom aktuellen Funktionswert $x_k$, sowie bei impliziten Verfahren dem Funktionswert $x_{k+1}$ abhängt. Deshalb werden diese Verfahren als Einschrittverfahren bezeichnet.\\
Im Gegensatz dazu hängt der Funktionswert $x_{k+1}$ bei Mehrschrittverfahren zusätzlich dazu von einer beliebigen Anzahl an Vorgängerwerten $x_{i-k+1},\ldots,x_i$ ab. Damit wird ein $k$-stufiges lineares Mehrschrittverfahren folgendermaßen definiert:
\begin{align}
	&a_k x_{i+k}+a_{k-1} x_{i+k-1}+\ldots+a_0 x_i \notag\\
	&\quad = T\left( b_k f(x_{i+k},t_{i+k}) + b_{k-1}f(x_{i+k-1},t_{i+k-1})+\ldots+b_0f(x_{i},t_{i}) \right)
	\label{eq:mehrschritt}
\end{align}
mit $a_k \neq 0$. Durch $\mathcal{Z}$-Transformation (nachzulesen zum Beispiel in \cite{digit}) lassen sich Mehrschrittverfahren auch durch die beiden Polynome
\begin{align}
	P_a(z) &= a_0 + a_1 z + \ldots + a_k z^k \\
	P_b(z) &= b_0 + b_1 z + \ldots + b_k z^k	
\end{align}
charakterisieren.
Ein Beispiel für ein Mehrschrittverfahren ist das (implizite) Milne-Simpson-Verfahren:
\begin{align}	
	x_{i+1} = x_{i-1} + \frac{T}{3} \left(f(x_{i+1},t_{i+1})  +4f(x_i,t_i)  +f(x_{i-1},t_{i-1})  \right)
\end{align}	

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Adams-Verfahren/Prädiktor-Korrektor-Verfahren}
Wie auch bei den Einschrittverfahren können Mehrschrittverfahren in explizite und implizite Verfahren unterteilt werden. In \cite{faires} wird gezeigt, dass implizite Verfahren im allgemeinen erheblich bessere Ergebnisse erzielen, als explizite Verfahren, jedoch das Auflösen der impliziten Gleichung nach dem gesuchten Funktionswert mit starkem Rechenaufwand verbunden sein kann.\\
Dies führt zu dem Gedanken, Approximationen, welche durch ein explizites Verfahren gewonnen wurden, durch ein implizites Verfahren zu verbessern. Diese Kombination aus explizitem und implizitem Verfahren wird als Prädiktor-Korrektor-Verfahren bezeichnet. 

Die hierfür am häufigsten verwendeten Mehrschrittverfahren sind die so genannten Adams-Verfahren. Dabei werden die expliziten Verfahren als \textit{Adams-Bashforth-Verfahren} und die impliziten Verfahren als \textit{Adams-Moulton-Verfahren} bezeichnet. (KOEFFIZIENTEN SIEHE ANHANG) Die Herleitung dieser Verfahren kann in \cite{gruene} nachvollzogen werden.\\
Nach \cite{faires} liegen Rechenaufwand und Genauigkeit bei einem $m$-stufigen \textit{Adams-Bashforth-Verfahren} und einem $m$-1-stufigen \textit{Adams-Moulton-Verfahren} im gleichen Größenbereich, wobei der lokale Fehler von $T^{m+1}$ abhängt. Wie bereits eingangs erwähnt, liefern die impliziten Verfahren jedoch deutlich genauere Approximationen.

Zur Durchführung des Prädiktor-Korrektor-Verfahrens wird zunächst mit dem expliziten $m$-stufigen \textit{Adams-Bashforth-Verfahren} ein Approximationswert $x_{i+1}^{(0)}$ berechnet, also die Prädiktion durchgeführt. Dieser wird dann in die rechte Seite der impliziten Gleichung des \textit{Adams-Moulton-Verfahren} eingesetzt, wodurch eine bessere Schätzung $x_{i+1}^{(1)}$ berechnet werden kann (Korrektur). Diese wird nun als Funktionswert $x(t_{i+1})$ angenommen.
In \cite{netomac} wird beschrieben, dass der Korrektor-Schritt in der Praxis iterativ wiederholt werden kann, um eine noch höhere Genauigkeit zu erzielen.

Da ein $k$-stufiges Mehrschrittverfahren zur Berechnung des Funktionswertes $x_i$ alle zurückliegenden Funktionswerte bis $x_{i-k}$ benötigt, ist der erste überhaupt berechenbare Funktionswert $x(t=t_k)$. Aus diesem Grund müssen Mehrschrittverfahren durch geeignete Einschrittverfahren \glqq gestartet\grqq \ werden. Man bezeichnet Einschrittverfahren im Gegensatz zu Mehrschrittverfahren aus diesem Grund auch als \textit{selbststartend}.

\subsection{BDF-Verfahren}
(Besonders geeignet für steife DGL aber wo einbringen?)
Eine weitere Klasse der Mehrschrittverfahren sind die so genannten \textit{Backwards Differentiation Formulas} (BDF). Für diese Verfahren gilt $P_b(z) = z^k$. Damit lassen sich eine Reihe impliziter Verfahren erzeugen, die besonders gut für steife Differentialgleichungen geeignet sind.

%
%\subsection{Schrittweitensteuerung}
%(WAHRSCHEINLICH WEGLASSEN!)
%Die Methoden zur Schrittweitensteuerung lassen sich weitgehend von Einschrittverfahren übertragen. Bei Mehrschrittverfahren besteht lediglich das Problem, dass die Schrittweite in letzten $k$ Schritten übereinstimmen muss, damit Gleichung (\ref{eq:mehrschritt}) sinnvoll ausgewertet werden kann. 
%\subsection{Extrapolationsverfahren}
%(wahrscheinlich weglassen, gehoert zu den Mehrschrittverfahren!!)
%TABELLE MIT VERFAHREN, KONSISTENZORDNUNG und STABILITÄT!!!!

% Nach Friedrich: Numerische Methoden:
%\section{Beschreibung der Integrationsverfahren}
%	\subsection{Explizite Einschrittverfahren}
%		\subsubsection{Explizites Eulerverfahren}
%		\subsubsection{Trapezregel}
%		\subsubsection{Runge-Kutta-Verfahren}
%	\subsection{Implizite Einschrittverfahren}
%	\subsection{Impliztes Eulerverfahren}
%	\subsection{explizite Mehrschrittverfahren}
%	\subsection{implizite Mehrschrittverfahren}
%	\subsection{Prädiktor-Korrektor-Verfahren}

% Nach Faires: Numerische Methoden>
% \subsection{Eulersches Verfahren}
% \subsection{Runge-Kutta Verfahren}
% \subsubsection{Mittelpunktmethode}
% \subsubsection{modifiziertes Eulersches Verfahren $\hat{=}$ implizites Eulerverfahren}
% \subsubsection{Heunsches Verfahren}
% \subsubsection{Runge-Kutta Verfahren 4. Ordnung}
% \subsection{(Prädiktor-Korrektor Verfahren )$\hat{=}$Mehrschrittverfahren}
% --> Unterscheidung von explizit und implizit (????)
% \subsubsection{Adam-Bashforth ...(explizit)}
% \subsubsection{Adams-Moulton ....(implizit)}
% \subsubsection{Prädiktor-Korrektor Verfahren: Milnesche, Simpsonsche}
% Ausblick:(?) Extrapolationsverfahren und Adaptive Verfahren


\section{Stabilitätsanalyse der wichtigsten Methoden}
VIELLEICHT EINFACH: METHODEN AUS DIGITALE REGELUNG ANWENDEN, HILFE VON GRUENE UND NETOMAC SKRIPT!
Neben der Konvergenz des Fehlers mit der Schrittweite $e(t) = \mathcal{O}(T^p)$ ist für die Anwendbarkeit eines Verfahrens entscheidend, welche Voraussetzungen an die Schrittweite gestellt werden müssen, damit das Verfahren bei der Lösung von Differentialgleichungen stabil ist. Unter der Stabilität soll in diesem Zusammenhang die exponentielle Stabilität verstanden werden, wie sie in \cite{gruene} beschrieben wird. Um die Betrachtungen zu vereinfachen, soll sich an dieser Stelle auf die Klasse \textit{linearer zeitinvarianter Systeme} beschränkt werden, für die gilt:
\begin{align}
	\dot{x}=Ax.
\end{align}
Aus der Systemtheorie ist bekannt, dass ein solches System genau dann exponentiell stabil ist, wenn für alle Eigenwerte der Matrix $A$ gilt: $\Re \lambda_i < 0$, das heißt, die Eigenwerte liegen in der linken Halbebene der komplexen Zahlenebene $\mathbb{C}^-$.

\subsection{Steife Differentialgleichungen}
Zur Einführung soll das Anfangswertproblem
\begin{align}
	\dot{x}=\lambda x,\quad x(0)=x_0
	\label{eq:bsp}
\end{align}
betrachtet werden. Für diese einfache Differentialgleichung lautet die geschlossene Lösung $x(t)= e^{\lambda t} x_0$. Das heißt für $\lambda < 0$ konvergiert diese Lösung gegen $0$.
Eine Approximation des Systems mit dem expliziten Euler-Verfahren liefert
\begin{align}
	x_{i+1}=x_i + T \lambda x_i = (1+T\lambda)x_i.
\end{align}
Diese Differenzengleichung konvergiert genau dann ebenfalls gegen $0$, wenn 
\begin{align}
	|1+T\lambda| < 1
\end{align}
gilt. Für die Schrittweite $T$ muss also die Bedingung
\begin{align}
	T < \frac{2}{|\lambda|}
	\label{eq:Tbed}
\end{align}
erfüllt sein, damit die Approximation eine Sinnvolle Näherung darstellt. Es ist augenscheinlich, dass dies bei sehr schnellen Systemen mit $\lambda \ll 0$ zu sehr kleinen notwendigen Schrittweiten führt.\\
Aus diesem Grund werden solche Differentialgleichungen allgemein als \textit{steif} bezeichnet. Die Approximation von steifen Differentialgleichungen führt vor allem bei expliziten Verfahren zu Problemen und stellt die wesentliche Motivation zur Verwendung von impliziten Verfahren dar.
In Abbildung \ref{fig:example} ist die Approximation von Gleichung (\ref{eq:bsp}) mit dem expliziten Euler-Verfahren für verschiedene Schrittweiten dargestellt. 
\begin{figure}
\centering
\input{inhalt/Grafiken/euler_ex.tex}
\caption{Simulation des Beispielsystems mit explizitem Euler-Verfahren}
\label{fig:example}
\end{figure}

\subsection{Einschrittverfahren}
Das Beispiel der steifen Differentialgleichungen hat gezeigt, dass durch die Wahl der Schrittweite im allgemeinen das Stabilitätsverhalten des Verfahrens beeinflussen lässt. Im Folgenden sollen Bedingungen aufgezeigt werden, die an die Schrittweite gestellt werden müssen, um die Stabilität eines Verfahrens allgemein zu gewährleisten.

Nach \cite{gruene} lassen sich alle Runge-Kutta-Verfahren mit konstanter Schrittweite, also alle bisher betrachteten Einschrittverfahren ohne Schrittweitensteuerung durch die Differenzengleichung
\begin{align}
	x_{i+1}= \tilde{A} x_i 
\end{align}
beschreiben.
Nach \cite{digit} ist eine solche Differenzengleichung genau dann exponentiell stabil, wenn für alle Eigenwerte der Matrix $\tilde{A}$ stabil sind, das heißt $|\tilde{\lambda}_i|<1$ gilt. Dieser Bereich wird im Folgenden mit $B_1(0)$ bezeichnet.
Zur Untersuchung der Stabilität eines Verfahrens müsste also die Matrix $\tilde{A}$ aus den Koeffizienten des Verfahrens und der Matrix $A$ der zu Grunde liegenden Differentialgleichung berechnet werden.
Die Matrix der Differenzengleichung $\tilde{A}$ berechnet sich also als Funktion der Art
\begin{align}
	\tilde{A}= R(TA).
\end{align}
Diese Funktion nimmt für explizite Werte $z \in \mathbb{C}$ die Form
\begin{align}
	R(z) = 1 + zb^T \left( I-z\mathcal{A}  \right)^{-1} e
\end{align}
an, wobei $I$ für die Einheitsmatrix steht, $b = (b_1, \ldots, b_s)^T$ und $\mathcal{A}=(a_{ij})_{i,j=1,\ldots,s}$ die Koeffizienten des Verfahrens beinhalten und $e=(1,\ldots,1)^T \in \mathbb{R}^s$ gilt. $R(z)$ wird als die Stabilitätsfunktion des Verfahrens bezeichnet. Die Stabilitätsfunktion an sich ist nun unabhängig von der Schrittweite und der Dynamik der betrachteten Differentialgleichung und kann damit noch keine endgültige Aussage über die Stabilität des Verfahrens treffen. 
Um diese zu ermöglichen, gilt es herauszufinden, welche Bedingungen $A$ und $T$ erfüllen müssen, damit die Eigenwerte der Matrix $\tilde{A}$ stabil sind. 

Hierfür wird das Stabilitätsgebiet $S \subset \mathbb{C}$ eines Runge-Kutta-Verfahrens mit Stabilitätsfunktion $R$ definiert als die Menge von Eigenwerten $\lambda_i$, die $TA$ annehmen darf, damit $\tilde{A}=R(TA)$ exponentiell stabil ist. Ein Verfahren wird als $A$-stabil bezeichnet, wenn es für eine stabile Dynamik $A$ unabhängig von der Schrittweite stabil ist.

Das Stabilitätsgebiet entspricht dem Bereich, indem der Betrag der Stabilitätsfunktion kleiner eins ist:
\begin{align}
	S = \{z\in\mathbb{C} \big| |R(z)|<1 \}.
\end{align}
Damit lassen sich für alle betrachteten Verfahren Voraussetzungen an die Schrittweite in Abhängigkeit der Eigenwerte von $A$ berechnen. Es gilt zu beachten, dass \linebreak \mbox{$\lambda_i \in \Sigma(A) \Rightarrow T\lambda_i \in \Sigma(TA)$}. Allgemein gilt somit, je größer das Stabilitätsgebiet $S$, desto größer kann die Schrittweite $T$ gewählt werden, um Stabilität zu gewährleisten. 

Zur Vergleichbarkeit sollen nun die betrachteten Verfahren auf das Stabilitätsgebiet untersucht werden.
Für das explizite Euler-Verfahren ergibt sich $R_\mathrm{Eu,ex}(z) = 1+z$. Damit ergibt sich 
\begin{align}
	|R_\mathrm{Eu,ex}(z)| <1  \ \Leftrightarrow \ |1+z|<1,
\end{align}
also $S = \{ z\in\mathbb{C} \big| |1+z|<1\} = B_1(-1)$. Die Schrittweite muss also so gewählt werden, dass $T\lambda_i \in B_1(-1)$ gilt. Für das betrachtete Beispielsystem entspricht dies genau (\ref{eq:Tbed}).

Für das implizite Euler-Verfahren erhält man $R_\mathrm{Eu,im}(z) = \frac{1}{1-z}$. Für das Stabilitätsgebiet bedeutet das
\begin{align}
	|R_\mathrm{Eu,im}(z)| <1  \ \Leftrightarrow \ |1-z|>1,
\end{align}
das heißt $S$ ist $\mathbb{C}$ ohne den Kreis $B_1(1)$. Damit ist das implizite Euler-Verfahren -- wie viele implizite Verfahren -- $A$-stabil, was hilfreich bei der Simulation von stabilen Systemen ist. Allerdings enthält das Stabilitätsgebiet auch Bereiche, in denen die Approximation stabil ist, obwohl das eigentliche System instabil ist, wie zum Beispiel $\Re z > 1$. In diesem Fall würde die Instabilität eines Systems in der Simulation möglicherweise unentdeckt bleiben, was eines der Probleme des impliziten Euler-Verfahrens ist und eine Motivation für die Trapezregel liefert.
\input{inhalt/Grafiken/stabis.tex}


\section{Anwendung der Integrationsmethoden in Simulationssoftware}
\subsection{PSS Nettomac}
\subsection{PowerFactory}
RMS Simulation Algorithms \\
\textbullet     Highly accurate, fixed or variable step-size integration technique for solving AC and DC network load 
flow and dynamic model equations. This is combined with a non-linear electromechanical model 
representation to enable a high degree of solution accuracy, algorithmic stability and time range validity.\\
\textbullet     A-stable simulation algorithm for the efficient handling of stiff systems. This is applicable to all or any 
individually selected model featuring error-controlled automatic step-size adaptation, ranging from 
milliseconds up to minutes or even hours, including precise handling of interrupts and discontinuities.  
EMT Simulation Algorithms \\
\textbullet     The calculation of initial conditions is carried out prior to the EMT simulation, and is based on a solved 
load flow (symmetrical or asymmetrical). Consequently, there is no need for saving steady state 
conditions being reached after transients are damped out aiming in simulation re-starting under steady 
state conditions.  \\
\textbullet     Special numerical integration methods have been implemented in DIgSILENT PowerFactory in order to 
avoid numerical oscillations caused by switching devices and other non-linear characteristics.  \\
\textbullet    Highly accurate, fixed or variable step-size integration technique for solving AC and DC network 
transients and dynamic model equations. This is combined with a non-linear electromechanical model 
representation to enable a high degree of solution accuracy, algorithmic stability and time range validity. 
\subsection{PSSE}
\subsection{Eurostag}
The advanced dynamic functions of EUROSTAG® allow for the full range of transient, mid and long-term stability to be covered thanks to a robust algorithm using an auto-adaptative integration stepsize.
























\newpage
Hier ist das eigentliche Thema zu bearbeiten.

%\section{Einbindung von Bildern}
%\label{kap:einbindungbilder}
%Abbildungen sind mit Hilfe des Pakets \textit{graphicx} einzufügen. Sie können im PDF-Format durch die Nutzung des folgenden Codes implementiert werden.
%\begin{verbatim}
%\begin{figure}[!htb]\centering
% \includegraphics*[width = \textwidth]{beispiel}
% \caption{Beispiel für die Einbindung eines Bildes}
% \label{abb:beispiel}
%\end{figure}
%\end{verbatim}
%Das Ergebnis ist die Anzeige des Bildes, mittig, wie der Text breit mit der angegebenen Unterschrift. Alternativ kann bei der Breite eine absolute Angabe in mm erfolgen. Über das label \textit{abb:beispiel} kann das Bild referenziert werden.
%\begin{figure}[!htb]\centering
% \includegraphics*[width = \textwidth]{beispiel}
% \caption{Beispiel für die Einbindung eines Bildes}
% \label{abb:beispiel}
%\end{figure}
%Um auf das Bild \ref{abb:beispiel} zu verweisen, bedient man sich der folgenden Funktion:
%\begin{verbatim}
%\ref{abb:beispiel}
%\end{verbatim}
%Die referenzierte Nummerierung erfolgt Kapitelweise. Will man weiterhin eine Quelle in der Bildunterschrift angeben, so ist darauf zu achten, dass die Einbindung der Bildunterschriften durch ein optionales Element (eingeschlossen in eckigen Klammern) erweitert wird, welches die Beschriftung für das Abbildungsverzeichnis enthält:
%\begin{verbatim}
% \caption[Beispiel...]{Beispiel... , aus \cite{schwab}}
%\end{verbatim}
%Diese Variante verhindert, dass LaTex die Quellen bereits im Abbildungsverzeichnis zu zählen anfängt.
%
%\section{Einbindung von Tabellen}
%\label{kap:einbindungtabellen}
%Die Tabellen sollen mit Hilfe des Pakets \textit{tabularx} eingebunden werden. Im Folgenden ist ein Beispiel für die Einbindung von Tabellen aufgeführt. Mit
%\begin{verbatim}
%\begin{table}[!htb]
%\centering
%\caption{Beispiel einer Tabelle}
%\label{tab:tabelle1}
%\begin{tabularx}{\textwidth}{|X|c|c|c|c|c|c|c|c|}
%\hline
%        & Spalte 1 & Spalte 2 & Spalte 3 & Spalte 4 & Spalte 5 \\
%\hline
%Zeile 1 &          &          &          &          &          \\
%\hline
%Zeile 2 &          &          &          &          &          \\
%\hline
%Zeile 3 &          &          &          &          &          \\
%\hline
%\end{tabularx}
%\end{table}
%\end{verbatim}
%ergibt sich die folgende Tabellenausgabe \ref{tab:tabelle1}.
%\begin{table}[!htb]
%\centering
%\caption{Beispiel einer Tabelle}
%\label{tab:tabelle1}
%\begin{tabularx}{\textwidth}{|X|c|c|c|c|c|c|c|c|}
%\hline
% 				& Spalte 1 	& Spalte 2 	& Spalte 3 	& Spalte 4 	& Spalte 5 \\
%\hline
%Zeile 1 & 					& 					& 					& 					& \\
%\hline
%Zeile 2 & 					& 					& 					& 					& \\
%\hline
%Zeile 3 & 					& 					& 					& 					& \\
%\hline
%\end{tabularx}
%\end{table}
%Bei Angabe von Quellen in der Tabellenüberschrift ist ähnlich wie im Kapitel \ref{kap:einbindungbilder} zu verfahren.
%
%\section{Eingabe von Gleichungen}
%\label{kap:einbindunggleichungen}
%Die Eingabe von Gleichungen erfolgt nach dem folgenden Beispiel:
%\begin{verbatim}
%\begin{align}
%U=R \cdot I
%\end{align}
%\end{verbatim}
%Das Ergebnis ist die folgende Darstellung mit der automatischen Nummerierung:
%\begin{align}
%U=R \cdot I
%\end{align}
%Durch die Einbindung des eigens definierten Pakets \textit{befehle.sty} stehen zudem die folgenden Funktionen für die Gleichungseingabe zur Verfügung:
%\begin{tabbing}
%XXXXXX 	\= XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\kill
%einh{} 	\> Einheiten\\
%iz{}		\> Nicht-kursiver Index, unten\\
%izo{}		\> Nicht-kursiver Index, oben\\
%izf{}		\> Nicht-kursiver Index, unten, kleinere Schrift\\
%izof{}	\> Nicht-kursiver Index, oben, kleinere Schrift
%\end{tabbing}
%Die Anwendung der Funktionen kann anhand des folgenden Beispiels nachvollzogen werden. Mit dem Code
%\begin{verbatim}
%U\iz{R}=I \cdot R = 10\einh{A} \cdot 1\einh{$\Omega$}=10\einh{V}
%\end{verbatim}
%ergibt sich die folgende Ausgabe:
%\begin{align}
%U\iz{R}=I \cdot R = 10\einh{A} \cdot 1\einh{$\Omega$}=10\einh{V}
%\end{align}
%Weitere Funktionen können der Datei entnommen und individuell erweitert werden.
%
%\section{Quellenangabe}
%\label{kap:quellenangabe}
%Die Angabe von Quellen ist mit folgendem Code als Beispiel möglich:
%\begin{verbatim}
%\cite{schwab}
%\end{verbatim}
%Die Ausgabe wird an der Stelle eingefügt, an der man es einsetzt. Zum Beispiel hier: \cite{schwab}. Die Zahlen werden nach dem Vorkommen im Text vergeben und durchnummeriert. D.h. die nächste Angabe erhält die Nummer zwei und zwar hier: \cite{oedingoswald}. Die Einträge in der Literaturdatenbank können manuell in der Datei \textit{literatur.bib} oder mit der Software \textit{JabRef} angepasst werden.